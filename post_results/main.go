package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"log"

	"github.com/openconfig/models-ci/commonci"
)

// post_results posts the CI results for a given tool using the output from
// running the tool's script generated by cmd_gen. The location of the results
// is determined by common_ci.

const (
	// The title of the results uses the relevant emoji to show whether it
	// succeeded or failed.
	mdPassSymbol = ":white_check_mark:"
	mdFailSymbol = ":no_entry:"
	// IgnorePyangWarnings ignores all warnings from pyang or pyang-based tools.
	IgnorePyangWarnings = true
)

var (
	// flags
	validatorId  string
	modelRoot    string
	repoSlug     string
	prBranchName string
	commitSHA    string
	version      string

	// derived flags
	owner string
	repo  string
)

func init() {
	flag.StringVar(&validatorId, "validator", "", "unique name of the validator")
	flag.StringVar(&modelRoot, "modelRoot", "", "root directory to OpenConfig models")
	flag.StringVar(&repoSlug, "repo-slug", "openconfig/public", "repo where CI is run")
	flag.StringVar(&prBranchName, "pr-branch", "", "branch name of PR")
	flag.StringVar(&commitSHA, "commit-sha", "", "commit SHA of the PR")
	flag.StringVar(&version, "version", "", "version of the validator tool")
}

func lintSymbol(pass bool) string {
	if !pass {
		return mdFailSymbol
	}
	return mdPassSymbol
}

func sprintLineHTML(line string) string {
	return fmt.Sprintf("  <li>%s</li>\n", line)
}

// processAnyPyangOutput takes the raw pyang output and transforms it to an
// HTML format for display on a GitHub gist comment.
func processAnyPyangOutput(rawOut string, pass, noWarnings bool) (string, error) {
	var errorLines, nonErrorLines strings.Builder
	for _, line := range strings.Split(rawOut, "\n") {
		if line = strings.TrimSpace(line); line == "" {
			continue
		}

		sections := strings.SplitN(line, ":", 4)
		// warning/error lines from pyang have a "path:line#:status:message" format.
		if len(sections) < 4 {
			nonErrorLines.WriteString(sprintLineHTML(line))
			continue
		}
		filePath := strings.TrimSpace(sections[0])
		lineNumber := strings.TrimSpace(sections[1])
		status := strings.ToLower(strings.TrimSpace(sections[2]))
		message := strings.TrimSpace(sections[3])

		// Convert file path to relative path.
		var err error
		if filePath, err = filepath.Rel(modelRoot, filePath); err != nil {
			return "", fmt.Errorf("failed to calculate relpath at path %q (modelRoot %q) parsed from message %q: %v\n", filePath, modelRoot, line, err)
		}

		// When there is subpath information, remove it (as it's not useful to users) and re-compute information.
		// path:line#(subpath:line#):status:message
		subpathIndex := strings.Index(sections[1], "(")
		if subpathIndex != -1 {
			messageSections := strings.SplitN(sections[3], ":", 2)
			if len(messageSections) == 1 {
				// When there is subpath information, we expect there to be an extra colon due to the
				// subpath line number; so, this is unrecognized format.
				nonErrorLines.WriteString(sprintLineHTML(line))
				continue
			}
			lineNumber = strings.TrimSpace(sections[1][:subpathIndex])
			status = strings.ToLower(strings.TrimSpace(messageSections[0]))
			message = strings.TrimSpace(messageSections[1])
		}

		processedLine := fmt.Sprintf("%s (%s): %s: <pre>%s</pre>", filePath, lineNumber, status, message)
		switch {
		case strings.Contains(status, "error"):
			errorLines.WriteString(sprintLineHTML(processedLine))
		case strings.Contains(status, "warning"):
			if !noWarnings {
				nonErrorLines.WriteString(sprintLineHTML(processedLine))
			}
		default: // Unrecognized line, so write unprocessed output.
			nonErrorLines.WriteString(sprintLineHTML(line))
		}
	}

	var out strings.Builder
	if pass {
		out.WriteString("Passed.\n")
	}
	if errorLines.Len() > 0 || nonErrorLines.Len() > 0 {
		out.WriteString("<ul>\n")
		out.WriteString(errorLines.String())
		out.WriteString(nonErrorLines.String())
		out.WriteString("</ul>\n")
	}
	return out.String(), nil
}

func sprintSummaryHTML(pass bool, modelName, message string) string {
	return fmt.Sprintf("<details>\n  <summary>%s %s</summary>\n%s</details>\n", lintSymbol(pass), modelName, message)
}

// parseModelResultsHTML transforms the output files of the validator script into HTML
// to be displayed on GitHub.
func parseModelResultsHTML(validatorId, validatorResultDir string) (string, bool, error) {
	var htmlOut, modelHTML strings.Builder
	var prevModelDirName string

	allPass := true
	modelDirPass := true
	// Process each result file in lexical order.
	// Since result files are in "modelDir==model==status" format, this ensures we're processing by directory.
	// (Note that each modelDir has multiple models. Each model corresponds to a result file).
	if err := filepath.Walk(validatorResultDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return fmt.Errorf("handle failure accessing a path %q: %v\n", path, err)
		}

		components := strings.Split(info.Name(), "==")
		// Handle per-model output. Files should be in "modelDir==model==status" format; otherwise they're ignored.
		if !info.IsDir() && len(components) == 3 {
			modelDirName, modelName, status := components[0], components[1], components[2]

			// Write results one modelDir at a time in order to report overall modelDir status.
			if prevModelDirName != "" && modelDirName != prevModelDirName {
				htmlOut.WriteString(sprintSummaryHTML(modelDirPass, prevModelDirName, modelHTML.String()))
				modelHTML.Reset()
				modelDirPass = true
			}
			prevModelDirName = modelDirName

			modelPass := true
			switch status {
			case "pass":
			case "fail":
				allPass = false
				modelDirPass = false
				modelPass = false
			default:
				return fmt.Errorf("expect status at path %q to be true or false, got %v", path, status)
			}

			// Get output string.
			outBytes, err := ioutil.ReadFile(path)
			if err != nil {
				return fmt.Errorf("failed to read file at path %q: %v\n", path, err)
			}
			outString := string(outBytes)

			// Transform output string into HTML.
			if strings.Contains(validatorId, "pyang") {
				outString, err = processAnyPyangOutput(outString, modelPass, IgnorePyangWarnings)
				if err != nil {
					return fmt.Errorf("error encountered while processing output for validator %q: %v", validatorId, err)
				}
			} else {
				outString = strings.Join(strings.Split(outString, "\n"), "<br>\n")
				if modelPass {
					outString = "Passed.\n" + outString
				}
			}
			if !modelPass && outString == "" {
				outString = "Failed.\n"
			}

			modelHTML.WriteString(sprintSummaryHTML(modelPass, modelName, outString))
		}
		return nil
	}); err != nil {
		return "", false, err
	}

	// Edge case: handle last modelDir.
	htmlOut.WriteString(sprintSummaryHTML(modelDirPass, prevModelDirName, modelHTML.String()))

	return htmlOut.String(), allPass, nil
}

// getResult parses the results for the given validator and its results
// directory, and returns the string to be put in a GitHub gist comment as well
// as the status (i.e. pass or fail).
func getResult(validatorId, resultsDir string) (string, bool, error) {
	var outString string
	pass := true

	failFileBytes, err := ioutil.ReadFile(filepath.Join(resultsDir, commonci.FailFileName))
	// A non-existent or an empty fail file is a pass.
	var scriptFailOutString string
	if err == nil {
		scriptFailOutString = string(failFileBytes)
	}
	err = nil

	switch {
	// Non-empty fail string indicates a script execution failure when running a validator.
	case scriptFailOutString != "":
		outString = scriptFailOutString
		// For per-model validators, a failure here is distinct from a validation failure.
		if commonci.Validators[validatorId].IsPerModel {
			outString = "Validator script failed -- infra bug?\n" + outString
		}
		pass = false
	case !commonci.Validators[validatorId].IsPerModel:
		outString = "Test passed"
	default:
		outString, pass, err = parseModelResultsHTML(validatorId, resultsDir)
	}

	return outString, pass, err
}

// postResult runs the OpenConfig linter, and Go-based tests for the models
// repo. The results are written to a GitHub Gist, and into the PR that was
// modified, associated with the commit reference SHA.
func postResult() {
	var url, gistID string
	var err error
	var g *commonci.GithubRequestHandler
	commonci.Retry(5, "CreateCIOutputGist", func() error {
		g = commonci.NewGitHubRequestHandler()
		url, gistID, err = g.CreateCIOutputGist(validatorId, version)
		return err
	})
	if err != nil {
		log.Fatalf("error: couldn't create gist: %v", err)
	}

	resultsDir := commonci.ValidatorResultsDir(validatorId, version)
	outString, pass, err := getResult(validatorId, resultsDir)
	if err != nil {
		log.Fatalf("error, couldn't parse results: %v", err)
	}

	validatorName := validatorId + version
	g.AddGistComment(gistID, outString, fmt.Sprintf("%s %s", lintSymbol(pass), validatorName))

	prUpdate := &commonci.GithubPRUpdate{
		Owner:   owner,
		Repo:    repo,
		Ref:     commitSHA,
		URL:     url,
		Context: validatorName,
	}

	if !pass {
		prUpdate.NewStatus = "failure"
		prUpdate.Description = validatorName + " Failed"

		if uperr := g.UpdatePRStatus(prUpdate); uperr != nil {
			log.Printf("error: couldn't update PR to failed, error: %s", uperr)
		}
		return
	}

	prUpdate.NewStatus = "success"
	prUpdate.Description = validatorName + " Succeeded"
	if uperr := g.UpdatePRStatus(prUpdate); uperr != nil {
		log.Printf("error: couldn't update PR to succeeded: %s", uperr)
	}
}

func main() {
	flag.Parse()
	repoSplit := strings.Split(repoSlug, "/")
	owner = repoSplit[0]
	repo = repoSplit[1]
	if commitSHA == "" {
		log.Fatalf("no commit SHA")
	}
	if prBranchName == "" {
		log.Fatalf("no PR branch name supplied")
	}

	if _, ok := commonci.Validators[validatorId]; !ok {
		log.Fatalf("validator %q not found!", validatorId)
	}

	postResult()
}
